
// This file is automatically generated. Do not edit it directly.
import { createClient } from '@supabase/supabase-js';
import type { Database } from './types';

const SUPABASE_URL = "https://sqmmwywyggaxbwvqicoz.supabase.co";
const SUPABASE_PUBLISHABLE_KEY = "eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJpc3MiOiJzdXBhYmFzZSIsInJlZiI6InNxbW13eXd5Z2dheGJ3dnFpY296Iiwicm9sZSI6ImFub24iLCJpYXQiOjE3Mzk4NzM5MjgsImV4cCI6MjA1NTQ0OTkyOH0.6G-JkAzjY8sCzAE9ia8zTcQJ2uHm8xeyf_-JMWAiDi8";

// Import the supabase client like this:
// import { supabase } from "@/integrations/supabase/client";

// RequestQueue to manage and prioritize Supabase requests
class RequestQueue {
  private queue: Array<() => Promise<any>> = [];
  private isProcessing = false;
  private maxConcurrent = 3;
  private activeRequests = 0;

  async add<T>(request: () => Promise<T>, priority = false): Promise<T> {
    const requestPromise = new Promise<T>((resolve, reject) => {
      const executeRequest = async () => {
        try {
          this.activeRequests++;
          const result = await request();
          resolve(result);
          return result;
        } catch (error) {
          reject(error);
          throw error;
        } finally {
          this.activeRequests--;
          this.processQueue();
        }
      };

      // Add to front of queue if priority
      if (priority) {
        this.queue.unshift(executeRequest);
      } else {
        this.queue.push(executeRequest);
      }
    });

    this.processQueue();
    return requestPromise;
  }

  private processQueue() {
    if (this.isProcessing) return;
    this.isProcessing = true;

    setTimeout(() => {
      while (this.queue.length > 0 && this.activeRequests < this.maxConcurrent) {
        const request = this.queue.shift();
        if (request) {
          request().catch(() => {}); // Execute and catch any errors
        }
      }
      this.isProcessing = false;
      
      // If there are still items in the queue and we can process more, continue
      if (this.queue.length > 0 && this.activeRequests < this.maxConcurrent) {
        this.processQueue();
      }
    }, 0);
  }
}

// Create a global request queue
const requestQueue = new RequestQueue();

export const supabase = createClient<Database>(SUPABASE_URL, SUPABASE_PUBLISHABLE_KEY, {
  auth: {
    storage: localStorage,
    persistSession: true,
    autoRefreshToken: true,
    detectSessionInUrl: false, // Disable automatic detection of OAuth grants in URLs
    flowType: 'pkce',  // Use the modern PKCE flow for better security
  },
  global: {
    fetch: (url, options = {}) => {
      // Create a new timeout and controller for each request
      const controller = new AbortController();
      
      // Combine the signal from options with our abort controller
      const originalSignal = options?.signal;
      const { signal } = controller;
      
      if (originalSignal) {
        // If the original signal aborts, abort our controller too
        originalSignal.addEventListener('abort', () => controller.abort());
      }
      
      // Set a reasonable timeout (8 seconds)
      const timeout = setTimeout(() => {
        controller.abort();
      }, 8000);
      
      // Create options with the combined signal
      const fetchOptions: RequestInit = {
        ...options,
        signal
      };
      
      // Create a retry mechanism
      let retries = 2;
      
      const executeRequest = async (): Promise<Response> => {
        try {
          const response = await fetch(url, fetchOptions);
          
          // If we get a rate limit response, retry with backoff
          if (response.status === 429 && retries > 0) {
            retries--;
            const retryAfter = parseInt(response.headers.get('Retry-After') || '1', 10);
            await new Promise(resolve => setTimeout(resolve, retryAfter * 1000));
            return executeRequest();
          }
          
          return response;
        } catch (error: any) {
          // Only retry network errors or timeouts if we have retries left
          if ((error.name === 'AbortError' || error.name === 'TypeError') && retries > 0) {
            retries--;
            await new Promise(resolve => setTimeout(resolve, 1000));
            return executeRequest();
          }
          throw error;
        } finally {
          clearTimeout(timeout);
        }
      };
      
      // Add request to our queue
      const isAuthRequest = 
        (typeof url === 'string' && url.includes('/auth')) || 
        ((options as RequestInit)?.method === 'POST' && typeof url === 'string' && url.includes('/token'));
        
      return requestQueue.add(() => executeRequest(), isAuthRequest);
    }
  }
});

// Add an error handler for auth errors
supabase.auth.onAuthStateChange((event) => {
  console.log('Auth state changed:', event);
  if (event === 'SIGNED_OUT') {
    // Clear any cached data to ensure clean state after logout
    localStorage.removeItem('authCache');
  }
});
